# -*- coding: utf-8 -*-
"""python_ml.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tz7IzANxfkPu_kh1HfW6iuY7pg2eH7Re

#**Import dataset**
"""

import pandas as pd

class CsvLoader:
    def __init__(self, file_path):
        self.file_path = file_path
        self.data = None

    def load_file(self):
        self.data = pd.read_csv(self.file_path)
        print(f"Dataset loaded successfully from {self.file_path}")

    def display_head(self, n=10):
        if self.data is not None:
            print(self.data.head(n))
        else:
            print("Dataset not loaded. Please load the dataset first.")

# Usage example
file_path = '/content/spg.csv'
loader = CsvLoader(file_path)

# Load the dataset
loader.load_file()

# Display the first 10 rows
loader.display_head()

df = pd.read_csv('spg.csv')
df.head(10)

df.corr()["generated_power_kw"]

"""#**Standarize data**"""

from sklearn.preprocessing import StandardScaler, MinMaxScaler
df2 = pd.DataFrame(df)

# Standardization
# Initialize StandardScaler
scaler = StandardScaler()

# Fit and transform the data
scaled_data_standard = scaler.fit_transform(df2)

# Create DataFrame from scaled data
df2_standard = pd.DataFrame(scaled_data_standard, columns=df2.columns)
df2_standard

columns_to_round = ["temperature_2_m_above_gnd","mean_sea_level_pressure_MSL","shortwave_radiation_backwards_sfc","generated_power_kw"]

# Round off the values in the specified columns
df[columns_to_round] = df[columns_to_round].round()

# Display the modified DataFrame
print(df)

df1 = pd.DataFrame(df)

# Assign multiple columns to a variable
X = df1[["temperature_2_m_above_gnd","mean_sea_level_pressure_MSL","shortwave_radiation_backwards_sfc"]]

# Display the selected columns
print(X)

y = df["generated_power_kw"]
y

from sklearn.model_selection import train_test_split


X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=100)

X_train

y_train

from sklearn.linear_model import LinearRegression

lr = LinearRegression()
lr.fit(X_train, y_train)

y_lr_train_pred = lr.predict(X_train)
y_lr_test_pred = lr.predict(X_test)

from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Calculating RMSE and R² score for the training data
lr_train_rmse = np.sqrt(mean_squared_error(y_train, y_lr_train_pred))
lr_train_r2 = r2_score(y_train, y_lr_train_pred)

# Calculating RMSE and R² score for the testing data
lr_test_rmse = np.sqrt(mean_squared_error(y_test, y_lr_test_pred))
lr_test_r2 = r2_score(y_test, y_lr_test_pred)

print(f"Training RMSE: {lr_train_rmse}")
print(f"Training R²: {lr_train_r2}")
print(f"Testing RMSE: {lr_test_rmse}")
print(f"Testing R²: {lr_test_r2}")

"""#**Random Forest**"""

from sklearn.ensemble import RandomForestRegressor

rf = RandomForestRegressor(max_depth=2, random_state=100)
rf.fit(X_train, y_train)

y_rf_train_pred = rf.predict(X_train)
y_rf_test_pred = rf.predict(X_test)

from sklearn.metrics import mean_squared_error, r2_score
import numpy as np

# Calculating RMSE and R² score for the training data
lr_train_rmse = np.sqrt(mean_squared_error(y_train, y_lr_train_pred))
lr_train_r2 = r2_score(y_train, y_lr_train_pred)

# Calculating RMSE and R² score for the testing data
lr_test_rmse = np.sqrt(mean_squared_error(y_test, y_lr_test_pred))
lr_test_r2 = r2_score(y_test, y_lr_test_pred)

rf_results = pd.DataFrame(['Random forest', lr_train_rmse, lr_train_r2,lr_test_rmse, lr_test_r2]).transpose()
rf_results.columns = ['Method', 'Training RMSE', 'Training R2', 'Test RMSE', 'Test R2']
rf_results

import matplotlib.pyplot as plt
import numpy as np

plt.figure(figsize=(5,5))
plt.scatter(x=y_train, y=y_lr_train_pred, c="#7CAE00" ,alpha=0.3)

z = np.polyfit(y_train, y_lr_train_pred, 1)
p = np.poly1d(z)

plt.plot(y_train, p(y_train), '#F8766D')
plt.ylabel('Predict ')
plt.xlabel('Experimental ')